feeling stuck, maybe because the decision space is too big, or because I'm too
tired and I'm trying to work when I should be resting.


What I want is something to generate boilerplate I'm tired of writting over and
over.


I think the core feature here is probably a template / hookup system.  It might
be that you provide the template, and that the function for instantiating said
template is generated from the template.


So, for example, say we're generating a C++ program that prints a message and
closes.  The template might look like this:

"""
// fnord_template.cpp
import <iostream>
int main()
{
	std::cout << "「message:str」\n";
	return 0;
}
"""

The generated function might look like so:

"""
def generated(message:str) -> str:
    with open("fnord_template.cpp", "r") as template_file:
        template = generate_format_str(template_file.read())
    return template.format(message)
"""

Although, it's python, so we wouldn't really need to generate any functions
for instantiating such templates, and wouldn't strictly speaking need to
embed type info into the template either:

"""
def fill_template(template_name, *args, **kargs) -> str:
    with open("fnord_template.cpp", "r") as template:
	template = template.replace("{", "{{")
	template = template.replace("}", "}}")
	template = template.relpace("「", "{")
	template = template.relpace("」", "}")
        return template.format(message)
"""


So, yeah, that's a start.


And then nesting templates shouldn't be too bad, just fill one out, reindent,
and then plug it into another one.

"""
def indent(text):
    return "\n".join(["\t"+i if len(i.strip()) > 0 else i for i in text.split("\n")])
"""




